# 1.2.4. Programinė realizacija (Infrastruktūros dalis)

## Infrastruktūros architektūra

FinanceFlow sistemos infrastruktūra realizuota naudojant Infrastructure as Code (IaC) principą su Terraform įrankiu. Visa infrastruktūra yra aprašyta deklaratyviais HashiCorp Configuration Language (HCL) failais, kurie leidžia automatiškai sukurti, modifikuoti ir valdyti AWS debesijos resursus.

### Terraform modulių struktūra

Projekto infrastruktūra organizuota moduline architektūra, kur kiekvienas modulis atsako už konkretų infrastruktūros komponentą:

```
financemanager-infra-tf-aws/
├── main.tf                  # Pagrindinis orkestravimo failas
├── variables.tf             # Kintamųjų aprašymas
├── outputs.tf               # Išvesties reikšmės
├── providers.tf             # AWS provider konfigūracija
├── versions.tf              # Terraform versijų reikalavimai
├── backend.tf               # State valdymo konfigūracija
└── modules/                 # Modulių katalogas
    ├── networking/          # Tinklo infrastruktūra (VPC, subnets)
    ├── auth/                # Autentifikacija (Cognito)
    ├── database/            # Duomenų bazė (DynamoDB)
    ├── ecr/                 # Container registry
    ├── ecs/                 # Konteinerių orkestracija
    ├── alb/                 # Load balancer
    ├── cloudfront/          # CDN ir HTTPS
    ├── iam/                 # Prieigos valdymas
    ├── lambda/              # Serverless funkcijos
    └── api-gateway/         # HTTP API

```

## Pagrindiniai infrastruktūros moduliai

### 1. Networking modulis

**Paskirtis:** Sukuria dedikuotą VPC tinklą su viešais ir privačiais subnet'ais, užtikrinant tinklo izoliaciją ir saugumą.

**Pagrindiniai resursai:**
- VPC (Virtual Private Cloud) su CIDR 10.10.0.0/16
- 3 Public subnets skirtinguose Availability Zones (AZ)
- 3 Private subnets ECS task'ams
- Internet Gateway viešam interneto prieigai
- NAT Gateway privačių subnet'ų interneto prieigai
- Security Groups ALB ir ECS apsaugai

**Failas:** `modules/networking/main.tf`

```hcl
resource "aws_vpc" "main" {
  cidr_block           = var.vpc_cidr
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = merge(var.common_tags, {
    Name = "${var.name_prefix}_${var.app_name}-vpc-${var.environment}"
  })
}

resource "aws_subnet" "public" {
  count = length(var.public_subnet_cidrs)
  
  vpc_id                  = aws_vpc.main.id
  cidr_block              = var.public_subnet_cidrs[count.index]
  availability_zone       = var.availability_zones[count.index]
  map_public_ip_on_launch = true
  
  tags = merge(var.common_tags, {
    Name = "${var.name_prefix}_${var.app_name}-public-${substr(var.availability_zones[count.index], -2, 2)}"
    Tier = "public"
  })
}
```

**Svarbiausios funkcijos:**
- `create_vpc()` - sukuria VPC su DNS palaikymu
- `create_subnets()` - sukuria viešus ir privačius subnet'us
- `configure_routing()` - nustato maršrutizacijos taisykles
- `setup_security_groups()` - konfigūruoja security groups

**Išvestys:**
- `vpc_id` - VPC identifikatorius
- `public_subnet_ids` - Viešų subnet'ų ID sąrašas
- `private_subnet_ids` - Privačių subnet'ų ID sąrašas
- `alb_security_group_id` - ALB security group ID
- `ecs_security_group_id` - ECS security group ID

### 2. Auth modulis (Cognito)

**Paskirtis:** Valdyti vartotojų autentifikaciją ir autorizaciją naudojant AWS Cognito User Pool.

**Pagrindiniai resursai:**
- Cognito User Pool su email autentifikacija
- Cognito User Pool Client OAuth2 konfigūracijai
- Cognito Domain hosted UI puslapių prieigai

**Failas:** `modules/auth/main.tf`

```hcl
resource "aws_cognito_user_pool" "main" {
  name = "${var.name_prefix}-user-pool"
  
  username_attributes      = ["email"]
  auto_verified_attributes = ["email"]
  
  password_policy {
    minimum_length    = 8
    require_lowercase = true
    require_numbers   = true
    require_symbols   = false
    require_uppercase = true
  }
  
  account_recovery_setting {
    recovery_mechanism {
      name     = "verified_email"
      priority = 1
    }
  }
  
  tags = var.common_tags
}

resource "aws_cognito_user_pool_client" "main" {
  name         = "${var.name_prefix}-app-client"
  user_pool_id = aws_cognito_user_pool.main.id
  
  allowed_oauth_flows                  = ["code"]
  allowed_oauth_flows_user_pool_client = true
  allowed_oauth_scopes                 = ["email", "openid", "profile"]
  
  callback_urls = var.callback_urls
  logout_urls   = var.logout_urls
  
  token_validity_units {
    access_token  = "hours"
    id_token      = "hours"
    refresh_token = "days"
  }
}
```

**Konfigūruojami parametrai:**
- Slaptažodžio politika (minimumas 8 simboliai)
- OAuth2 flow tipas (authorization code)
- Token galiojimo trukmė (1h access, 30d refresh)
- Callback ir logout URL sąrašai

**Išvestys:**
- `user_pool_id` - Cognito User Pool ID
- `client_id` - App Client ID frontend konfigūracijai
- `domain` - Cognito hosted UI domain

### 3. Database modulis (DynamoDB)

**Paskirtis:** NoSQL duomenų bazės lentelių sukūrimas finansinių transakcijų ir kategorijų saugojimui.

**Failas:** `modules/database/main.tf`

```hcl
resource "aws_dynamodb_table" "transactions" {
  name         = "${var.name_prefix}-transactions"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "userId"
  range_key    = "transactionId"
  
  attribute {
    name = "userId"
    type = "S"
  }
  
  attribute {
    name = "transactionId"
    type = "S"
  }
  
  point_in_time_recovery {
    enabled = var.enable_pitr
  }
  
  server_side_encryption {
    enabled = true
  }
  
  tags = var.common_tags
}
```

**Lentelės struktūra:**

**Transactions lentelė:**
- Partition key: `userId` (String) - vartotojo identifikatorius
- Sort key: `transactionId` (String) - unikalus transakijos ID
- Billing mode: PAY_PER_REQUEST (on-demand)
- Encryption: AWS managed key

**Categories lentelė:**
- Partition key: `userId` (String)
- Sort key: `categoryId` (String)
- Billing mode: PAY_PER_REQUEST

**Duomenų struktūros pavyzdys:**

Transakijos įrašas:
```json
{
  "userId": "d3d43892-10b1-7079-0b89-b694faf0d9fc",
  "transactionId": "txn_2025-12-01_1234567890",
  "amount": 50.00,
  "category": "Maistas",
  "date": "2025-12-01T10:30:00Z",
  "description": "Pietūs restorane",
  "type": "expense"
}
```

### 4. ECS modulis (Konteinerių orkestracija)

**Paskirtis:** Fargate konteinerių vykdymas ir orkestracija, užtikrinant aplikacijos high availability.

**Failas:** `modules/ecs/main.tf`

```hcl
resource "aws_ecs_cluster" "main" {
  name = "${var.name_prefix}-cluster"
  
  setting {
    name  = "containerInsights"
    value = "disabled"
  }
  
  tags = var.common_tags
}

resource "aws_ecs_task_definition" "main" {
  family                   = "${var.name_prefix}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.cpu
  memory                   = var.memory
  execution_role_arn       = var.task_execution_role_arn
  task_role_arn            = var.task_role_arn
  
  container_definitions = jsonencode([
    {
      name      = "${var.name_prefix}-app"
      image     = var.container_image
      essential = true
      portMappings = [
        {
          containerPort = var.container_port
          protocol      = "tcp"
        }
      ]
      environment = [
        for key, value in var.environment_variables : {
          name  = key
          value = value
        }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          "awslogs-group"         = aws_cloudwatch_log_group.ecs.name
          "awslogs-region"        = data.aws_region.current.name
          "awslogs-stream-prefix" = "ecs"
        }
      }
    }
  ])
  
  tags = var.common_tags
}
```

**Konfigūracijos parametrai:**
- CPU: 512 vCPU units (0.5 vCPU)
- Memory: 1024 MB (1 GB)
- Network mode: awsvpc (kiekvienam task'ui atskiras ENI)
- Launch type: FARGATE (serverless)

**Task rolės:**
- `execution_role` - leidžia ECS agent'ui pull'inti image'us ir rašyti logs
- `task_role` - suteikia konteineriui prieigą prie DynamoDB

### 5. ALB modulis (Application Load Balancer)

**Paskirtis:** HTTP/HTTPS traffic'o paskirstymas tarp ECS task'ų ir health check'ų atlikimas.

**Failas:** `modules/alb/main.tf`

```hcl
resource "aws_lb" "main" {
  name               = var.name_prefix
  internal           = false
  load_balancer_type = "application"
  security_groups    = [var.security_group_id]
  subnets            = var.subnet_ids
  
  enable_deletion_protection = false
  enable_http2              = true
  
  tags = var.common_tags
}

resource "aws_lb_target_group" "main" {
  name        = "${var.name_prefix}-tg"
  port        = var.container_port
  protocol    = "HTTP"
  vpc_id      = var.vpc_id
  target_type = "ip"
  
  health_check {
    enabled             = true
    healthy_threshold   = 2
    unhealthy_threshold = 3
    timeout             = 5
    interval            = 30
    path                = "/health"
    matcher             = "200"
  }
  
  deregistration_delay = 30
  
  tags = var.common_tags
}
```

**Health check konfigūracija:**
- Endpoint: `/health`
- Interval: 30s
- Timeout: 5s
- Healthy threshold: 2 successful checks
- Unhealthy threshold: 3 failed checks

### 6. CloudFront modulis

**Paskirtis:** HTTPS įjungimas (Cognito reikalavimas) ir statinio turinio cache'inimas globaliame CDN tinkle.

**Failas:** `modules/cloudfront/main.tf`

```hcl
resource "aws_cloudfront_distribution" "main" {
  enabled             = true
  is_ipv6_enabled     = true
  default_root_object = "index.html"
  price_class         = "PriceClass_100"
  
  origin {
    domain_name = var.alb_dns_name
    origin_id   = "alb"
    
    custom_origin_config {
      http_port              = 80
      https_port             = 443
      origin_protocol_policy = "http-only"
      origin_ssl_protocols   = ["TLSv1.2"]
    }
  }
  
  default_cache_behavior {
    allowed_methods          = ["DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT"]
    cached_methods           = ["GET", "HEAD"]
    target_origin_id         = "alb"
    viewer_protocol_policy   = "redirect-to-https"
    compress                 = true
    cache_policy_id          = data.aws_cloudfront_cache_policy.caching_optimized.id
    origin_request_policy_id = data.aws_cloudfront_origin_request_policy.all_viewer.id
  }
  
  viewer_certificate {
    cloudfront_default_certificate = true
  }
  
  restrictions {
    geo_restriction {
      restriction_type = "none"
    }
  }
  
  tags = var.common_tags
}
```

**Cache strategijos:**
- Static assets (HTML, CSS, JS): Caching Optimized policy
- API endpoints (/api/*, /users/*): No-cache policy
- SPA routing: Custom error responses redirect 404/403 į index.html

### 7. IAM modulis

**Paskirtis:** Prieigos teisių valdymas tarp AWS resursų pagal least privilege principą.

**Failas:** `modules/iam/main.tf`

**Sukuriamos rolės:**

1. **ECS Task Execution Role:**
```hcl
resource "aws_iam_role" "ecs_task_execution" {
  name = "${var.name_prefix}-ecs-task-execution"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ecs-tasks.amazonaws.com"
        }
      }
    ]
  })
  
  tags = var.common_tags
}
```

**Teisės:** ECR image pull, CloudWatch logs write

2. **ECS Task Role:**
```hcl
resource "aws_iam_role_policy" "dynamodb_access" {
  name = "${var.name_prefix}-dynamodb-access"
  role = aws_iam_role.ecs_task.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "dynamodb:GetItem",
          "dynamodb:PutItem",
          "dynamodb:UpdateItem",
          "dynamodb:DeleteItem",
          "dynamodb:Query",
          "dynamodb:Scan"
        ]
        Resource = [
          "arn:aws:dynamodb:${var.region}:${var.account_id}:table/tf_financeflow-*"
        ]
      }
    ]
  })
}
```

**Teisės:** DynamoDB read/write tik su `tf_financeflow-` prefix

### 8. Lambda modulis (AI integracija)

**Paskirtis:** Serverless funkcija OpenAI API integracijai biudžeto optimizavimo rekomendacijoms.

**Failas:** `modules/lambda/main.tf`

```hcl
resource "aws_lambda_function" "openai" {
  filename         = "${path.module}/lambda.zip"
  function_name    = "${var.name_prefix}-openai"
  role            = aws_iam_role.lambda.arn
  handler         = "index.handler"
  runtime         = "nodejs20.x"
  timeout         = var.timeout
  memory_size     = var.memory_size
  
  environment {
    variables = {
      OPENAI_API_KEY = var.openai_api_key
    }
  }
  
  tags = var.common_tags
}
```

**Konfigūracija:**
- Runtime: Node.js 20.x
- Memory: 256 MB
- Timeout: 30s
- Trigger: API Gateway HTTP API

## Modulių tarpusavio ryšiai

### Duomenų srautai tarp modulių

```
┌──────────────┐
│  CloudFront  │ (HTTPS endpoint)
└──────┬───────┘
       │
       ▼
┌──────────────┐
│     ALB      │ (HTTP load balancer)
└──────┬───────┘
       │
       ▼
┌──────────────┐      ┌──────────────┐
│  ECS Tasks   │◄────►│  DynamoDB    │
│  (Private    │      │  (NoSQL DB)  │
│   Subnets)   │      └──────────────┘
└──────┬───────┘
       │
       ▼
┌──────────────┐
│  NAT Gateway │ (Internet access)
└──────────────┘
```

### Dependencies grafikas

```
networking (VPC, Subnets, SGs)
    ├── alb (depends_on networking)
    ├── ecs (depends_on networking, alb)
    └── cloudfront (depends_on alb)

auth (Cognito) ──► cloudfront (callback URLs)

database (DynamoDB) ──► ecs (via IAM)

iam (Roles) ──► ecs (task roles)
            ──► lambda (execution role)

lambda ──► api_gateway (integration)
```

## State valdymas

**Backend konfigūracija:** `backend.tf`

```hcl
terraform {
  backend "local" {
    path = "terraform.tfstate"
  }
}
```

**State failas saugo:**
- Visų sukurtų resursų ID ir ARN
- Resource dependencies
- Output reikšmes
- Provider konfigūracijas

## Deployment procesas

### 1. Inicializacija
```bash
terraform init
```
Atsisiunčia AWS provider plugin'ą ir inicializuoja backend'ą.

### 2. Planavimas
```bash
terraform plan -out=tfplan
```
Sugeneruoja execution planą, parodydamas kokius resursus sukurs/modifikuos/ištrins.

### 3. Pritaikymas
```bash
terraform apply tfplan
```
Vykdo planą ir sukuria AWS resursus.

### 4. Išvestys
```bash
terraform output
```
Grąžina svarbias reikšmes (CloudFront URL, Cognito client ID, etc.)

## Resursų tagging strategija

Visi resursai žymimi šiais tag'ais:
- `ManagedBy: terraform` - identifikuoja automatiškai sukurtus resursus
- `TerraformPrefix: tf_` - atskiria nuo manually sukurtų
- `Environment: prod` - aplinkos tipas
- `Project: financeflow` - projekto pavadinimas
- `Owner: thesis-student` - atsakingas asmuo

Tai leidžia:
- Lengvai atskirti Terraform ir manual resursus
- Filtruoti resursus AWS Console
- Skaičiuoti costs per projektą
- Automatizuoti cleanup operacijas

## Saugumo aspektai

### Network Security
- Private subnets su NAT gateway
- Security Groups su least privilege rules
- ALB priima tik 80/443 portus
- ECS priima trafic'ą tik iš ALB

### IAM Security
- Separate roles ECS execution ir task
- DynamoDB prieiga tik per resource prefix
- Lambda funkcija su minimaliomis teisėmis

### Data Security
- DynamoDB server-side encryption enabled
- HTTPS enforced per CloudFront
- Cognito password policy (8+ chars, uppercase, lowercase, numbers)

## Išvados

Terraform infrastruktūros kodas užtikrina:
1. **Reprodukuojamumą** - infrastruktūrą galima atkurti bet kurioje AWS account
2. **Versijavimą** - visas kodas Git repository
3. **Automatizaciją** - deployment per vieną komandą
4. **Dokumentaciją** - kodas yra dokumentacija
5. **Saugumą** - least privilege IAM roles
6. **Kainų optimizaciją** - pay-per-request DynamoDB, Fargate Spot pricing

Modulinė architektūra leidžia lengvai modifikuoti atskirus komponentus neliečiant visos sistemos.
